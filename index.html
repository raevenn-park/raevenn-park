<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Vertical Rotary Parking System</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden;
        }
        canvas {
            border: 2px solid #cbd5e1;
            background-color: #ffffff;
            border-radius: 1rem;
            display: block;
            margin: 0 auto;
            max-width: 100%;
            height: auto;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
    </style>
</head>
<body class="bg-gradient-to-br from-indigo-50 via-purple-50 to-pink-50">
    <div class="flex flex-col items-center p-6 bg-white rounded-2xl shadow-xl border border-gray-100 max-w-lg w-full md:max-w-xl lg:max-w-2xl">
        <h1 class="text-3xl md:text-4xl font-extrabold text-gray-800 mb-6 text-center leading-tight">2D Vertical Rotary Parking System</h1>
        <p class="text-gray-600 mb-8 text-center max-w-prose">
            This 2D model simulates a **vertical rotary parking system** with **6 slots**. Click the button below to see the system rotate, bringing different parking spaces to the ground level.
        </p>

        <canvas id="parkingCanvas" class="w-full h-96"></canvas>

        <button id="rotateButton"
                class="mt-8 px-8 py-3 bg-gradient-to-r from-blue-500 to-indigo-600 text-white font-semibold rounded-full shadow-lg hover:shadow-xl transform hover:scale-105 transition-all duration-300 ease-in-out
                       focus:outline-none focus:ring-4 focus:ring-blue-300 active:bg-indigo-700">
            Rotate System (Next Slot)
        </button>
    </div>

    <script>
        const canvas = document.getElementById('parkingCanvas');
        const ctx = canvas.getContext('2d');
        const rotateButton = document.getElementById('rotateButton');

        // Configuration for the parking system
        const numSlots = 6;              // Number of parking slots
        const slotWidth = 80;            // Width of each parking slot (platform)
        const slotHeight = 30;           // Height of each parking slot (platform thickness)
        const slotVerticalSpacing = 60;  // Vertical space between the center of adjacent slots
        const frameWidth = slotWidth + 40; // Overall width of the vertical frame
        const carLength = slotWidth * 0.7; // Length of the car inside the slot
        const carWidth = slotHeight * 0.7; // Width of the car inside the slot

        // Represents the vertical offset of the entire rotating system
        // This will be adjusted during rotation to simulate movement
        let rotationOffset = 0; // Current vertical offset for the system (in pixels)

        // The maximum vertical travel for the entire system before it needs to wrap around
        const totalSystemHeight = numSlots * slotVerticalSpacing;

        /**
         * Sets the canvas dimensions to match its display size.
         * This prevents blurring on high-DPI screens and ensures responsiveness.
         */
        function resizeCanvas() {
            const style = getComputedStyle(canvas);
            const displayWidth = parseInt(style.width, 10);
            const displayHeight = parseInt(style.height, 10);

            if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
                canvas.width = displayWidth;
                canvas.height = displayHeight;
                drawParkingSystem(); // Redraw content after resizing
            }
        }

        /**
         * Draws a simple car shape.
         * @param {CanvasRenderingContext2D} context - The canvas 2D rendering context.
         * @param {number} x - X coordinate of the car's center.
         * @param {number} y - Y coordinate of the car's center.
         * @param {number} length - Length of the car.
         * @param {number} width - Width of the car.
         */
        function drawCar(context, x, y, length, width) {
            context.fillStyle = '#fefefe'; // light gray/off-white for car body
            context.strokeStyle = '#6b7280'; // gray-500
            context.lineWidth = 1;

            // Car body
            context.fillRect(x - length / 2, y - width / 2, length, width);
            context.strokeRect(x - length / 2, y - width / 2, length, width);

            // Simple windows (top part of the car)
            context.fillStyle = '#94a3b8'; // slate-400
            context.fillRect(x - length / 4, y - width / 2 - width * 0.2, length / 2, width * 0.4);
            context.strokeRect(x - length / 4, y - width / 2 - width * 0.2, length / 2, width * 0.4);
        }

        /**
         * Draws the 2D vertical rotary parking system on the canvas.
         * This function clears the canvas and redraws all elements based on the current state.
         */
        function drawParkingSystem() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const centerX = canvas.width / 2;
            const groundY = canvas.height - 80; // Fixed ground level position

            // Draw the main vertical frame
            ctx.strokeStyle = '#4b5563'; // gray-600
            ctx.lineWidth = 8;
            ctx.lineCap = 'round'; // Rounded ends for structure

            // Left vertical beam
            ctx.beginPath();
            ctx.moveTo(centerX - frameWidth / 2, groundY);
            ctx.lineTo(centerX - frameWidth / 2, groundY - totalSystemHeight - 50); // Extend above slots
            ctx.stroke();

            // Right vertical beam
            ctx.beginPath();
            ctx.moveTo(centerX + frameWidth / 2, groundY);
            ctx.lineTo(centerX + frameWidth / 2, groundY - totalSystemHeight - 50); // Extend above slots
            ctx.stroke();

            // Top arch/beam
            ctx.beginPath();
            ctx.moveTo(centerX - frameWidth / 2, groundY - totalSystemHeight - 50);
            ctx.lineTo(centerX + frameWidth / 2, groundY - totalSystemHeight - 50);
            ctx.stroke();

            // Draw connecting beams/tracks on the sides
            ctx.strokeStyle = '#6b7280'; // gray-500
            ctx.lineWidth = 4;
            const beamOffset = frameWidth / 2 - 10; // Inset the beams slightly
            for (let i = 0; i < numSlots; i++) {
                const initialSlotY = groundY - (i * slotVerticalSpacing) - (slotHeight / 2);
                const currentSlotY = initialSlotY + rotationOffset;

                // Only draw slots that are within the visible frame
                if (currentSlotY > (groundY - totalSystemHeight - 50) && currentSlotY < (groundY + slotHeight)) {
                    // Left horizontal connector
                    ctx.beginPath();
                    ctx.moveTo(centerX - beamOffset, currentSlotY - slotHeight / 2);
                    ctx.lineTo(centerX - beamOffset - 15, currentSlotY - slotHeight / 2); // Small extension
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(centerX - beamOffset, currentSlotY + slotHeight / 2);
                    ctx.lineTo(centerX - beamOffset - 15, currentSlotY + slotHeight / 2);
                    ctx.stroke();

                    // Right horizontal connector
                    ctx.beginPath();
                    ctx.moveTo(centerX + beamOffset, currentSlotY - slotHeight / 2);
                    ctx.lineTo(centerX + beamOffset + 15, currentSlotY - slotHeight / 2); // Small extension
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(centerX + beamOffset, currentSlotY + slotHeight / 2);
                    ctx.lineTo(centerX + beamOffset + 15, currentSlotY + slotHeight / 2);
                    ctx.stroke();

                    // Draw the parking slot platform
                    ctx.fillStyle = '#34d399'; // emerald-400 (platform color)
                    ctx.strokeStyle = '#059669'; // emerald-600
                    ctx.lineWidth = 2;
                    ctx.fillRect(centerX - slotWidth / 2, currentSlotY - slotHeight / 2, slotWidth, slotHeight);
                    ctx.strokeRect(centerX - slotWidth / 2, currentSlotY - slotHeight / 2, slotWidth, slotHeight);

                    // Draw a car placeholder inside the slot
                    drawCar(ctx, centerX, currentSlotY, carLength, carWidth);
                }
            }


            // --- Draw the Ground Level ---
            ctx.strokeStyle = '#6b7280'; // gray-500
            ctx.lineWidth = 4;
            // Draw the ground line
            ctx.beginPath();
            ctx.moveTo(centerX - frameWidth * 1.2, groundY);
            ctx.lineTo(centerX + frameWidth * 1.2, groundY);
            ctx.stroke();

            // Draw the ground access platform/ramp
            ctx.fillStyle = '#e5e7eb'; // gray-200
            ctx.strokeStyle = '#9ca3af'; // gray-400
            ctx.lineWidth = 2;
            const rampWidth = slotWidth + 40;
            const rampHeight = 25;
            ctx.fillRect(centerX - rampWidth / 2, groundY, rampWidth, rampHeight);
            ctx.strokeRect(centerX - rampWidth / 2, groundY, rampWidth, rampHeight);

            // Text for ground access
            ctx.fillStyle = '#4f46e5'; // indigo-600
            ctx.font = '14px Inter';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top'; // Align text to the top of the given y
            ctx.fillText('Ground Access', centerX, groundY + rampHeight + 5);

            // Indicate the current slot at ground level
            ctx.fillStyle = '#ef4444'; // red-500
            ctx.font = '16px Inter';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            // Find which slot is currently aligned with the ground level
            // This is a simplified check based on rotationOffset
            // A more robust check might involve knowing the initial y-position of each slot relative to the ground
            // For now, let's assume the "bottom" slot of the system is the one at ground level
            const groundSlotIndex = Math.round((-rotationOffset / slotVerticalSpacing) % numSlots);
            ctx.fillText(`Current Slot at Ground: ${ (groundSlotIndex + numSlots) % numSlots + 1}`, centerX, groundY - 10);
        }

        /**
         * Rotates the parking slots vertically by one position.
         */
        function rotateSlots() {
            // Move the system up by one slot's vertical spacing
            rotationOffset -= slotVerticalSpacing;

            // This ensures the system "wraps around" smoothly
            // If the offset becomes too negative (system has moved up past its logical end),
            // reset it to simulate the top slot appearing at the bottom.
            if (Math.abs(rotationOffset) >= totalSystemHeight) {
                 rotationOffset = 0; // Reset or adjust based on desired wrap-around
            }

            drawParkingSystem(); // Redraw with the new rotation offset
        }

        /**
         * Initializes the canvas and sets up event listeners.
         */
        function init() {
            resizeCanvas(); // Initial canvas resize and draw
            rotateButton.addEventListener('click', rotateSlots); // Add event listener for the rotate button
            window.addEventListener('resize', resizeCanvas); // Add event listener for window resize
        }

        // Call the initialization function when the window loads
        window.onload = init;

    </script>
</body>
</html>
